using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AutoRegisterSourceGen;

[Generator]
public class PageRegisterGenerator : IIncrementalGenerator
{
    private readonly Regex _classNameRegex = new(Constants.ClassNameRegex);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {

        // #if DEBUG
        // if (System.Diagnostics.Debugger.IsAttached)
        // {
        //     System.Diagnostics.Debugger.Launch();
        // }
        // #endif
        var syntaxProvider = context.SyntaxProvider.CreateSyntaxProvider(
                (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax,
                (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(c => c is not null);

        var compilation = context.CompilationProvider.Combine(syntaxProvider.Collect());

        context.RegisterPostInitializationOutput((ctx) => ctx.AddSource(
            Constants.PageRegisterGeneratorAttribute,
            BuildPageRegisterGeneratorAttribute()));

     




        context.RegisterSourceOutput(compilation, Execute);
    }

    private void Execute(SourceProductionContext context, (Compilation Left, ImmutableArray<ClassDeclarationSyntax> Right) compilationTuple)
    {
        var (compilation, classes) = compilationTuple;

        var attributeAutoGenSymbol = compilation.GetTypeByMetadataName(Constants.PageRegisterGeneratorAttributeFullName);

        if (attributeAutoGenSymbol is null)
        {
            // Stop the generator if no such attribute has been found (shouldn't happen as it's defined in the same assembly)
            return;
        }

        var classWithAutoGenAttributeData = GetAllClasses(compilation.GlobalNamespace)
            // .SkipWhile(t => t.GetAttributes().First(ad => ad.AttributeClass.Name == Constants.DoNotRegisterAttribute) is not null )
            .Select(t => new
            {
                Class = t,
                AttributeData = t
                    .GetAttributes()
                    .FirstOrDefault(ad => ad .AttributeClass is not null && ad.AttributeClass.Equals(attributeAutoGenSymbol, SymbolEqualityComparer.Default))
            })
            .First(t => t.AttributeData != null);

        if (classWithAutoGenAttributeData .Class is null)
        {
            // Stop the generator if no class with the attribute has been found
            return;
        }

        if (classWithAutoGenAttributeData.AttributeData.ConstructorArguments.FirstOrDefault().Value is not string suffix || string.IsNullOrWhiteSpace(suffix))
        {
            // Stop the generator if the suffix is null or an empty string
            context.ReportDiagnostic(
                Diagnostic.Create(
                    new DiagnosticDescriptor(
                        Constants.ARG001,
                        Constants.Error,
                        $"The {Constants.AutoRegisterViewModelsAttribute} suffix parameter is required and may not be null or empty and the class name must be valid",
                        Constants.ErrorCategoryCompilation, DiagnosticSeverity.Error,
                        true),
                    null));

            return;
        }

        var namespaceName = classWithAutoGenAttributeData.Class.ContainingNamespace.ToDisplayString();

        var routeClassDeclarationSyntaxList = classes.Where(c => c.Identifier.Text.EndsWith(suffix)).ToList();
        var routeNameList = routeClassDeclarationSyntaxList.Select(pageClass => pageClass.Identifier.Text).ToImmutableHashSet();

        var routesAndTypenamesDictionary = new Dictionary<string, string>();

        foreach (var route in routeNameList)
        {
            var routeClass = classes.FirstOrDefault(c => c.Identifier.Text == route);
            var semanticModel = compilation.GetSemanticModel(routeClass.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(routeClass);
            var routeTypename = $"{classSymbol.ContainingNamespace}.{route}";
            routesAndTypenamesDictionary.TryAdd(route, routeTypename);
        }


        var source = BuildSource(routeNameList, routesAndTypenamesDictionary, namespaceName);

        context.AddSource(Constants.PagesGenFileName, source);
    }

    private static string BuildSource(IReadOnlyCollection<string> routeNameList, Dictionary<string, string> routesAndNamespacesDictionary, string namespaceName)
    {

        var code = string.Join("\n", routeNameList.Select(route =>
        {
            var routeTypename = routesAndNamespacesDictionary[route];
            return $@"
                Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddTransient<{routeTypename}>(services);
            ";
        }));

        var source = $$"""
                       // <auto-generated/>
                       using System.Collections.ObjectModel;
                       using Microsoft.Extensions.DependencyInjection;
                       
                       namespace {{Constants.Namespace}}
                       {
                           public static class RegisterPages
                           {
                           
                               public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddTransientPages(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
                               {
                                    {{code}}
                                    
                                    return services;
                                }
                           
                           
                           
                           }
                       }
                       """;
        return source;
    }

    // Helper method to get all classes in a namespace
    private static IEnumerable<INamedTypeSymbol> GetAllClasses(INamespaceSymbol namespaceSymbol)
    {
        foreach (var member in namespaceSymbol.GetMembers())
        {
            if (member is INamespaceSymbol childNamespace)
            {
                foreach (var childClass in GetAllClasses(childNamespace))
                {
                    yield return childClass;
                }
            }
            else if (member is INamedTypeSymbol { TypeKind: TypeKind.Class } classSymbol)
            {
                yield return classSymbol;
            }
        }
    }

    private static string BuildPageRegisterGeneratorAttribute()
    {

        return $$"""
               using System;
               namespace {{Constants.Namespace}};
               
               [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
               public class {{Constants.PageRegisterGeneratorAttribute}}: Attribute
               {
                   public string Suffix { get; }
               
                   public {{Constants.PageRegisterGeneratorAttribute}}(string suffix)
                   {
                       Suffix = suffix;
                   }
               
               } 
               """;
    }




}